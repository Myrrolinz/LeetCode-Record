题号,名称,感想,一刷
704,binary search,需要在函数内进行循环，且分成左 中 右三个部分，左和右都是左闭右开,5/3/2024
27,remove element,双指针（但我O(2n)也是O(n)啊！）,5/3/2024
977,squares of a sorted array,双指针（看了解答再写的）,5/3/2024
209,minimum size subarray sum,滑动窗口（这题完全不会做,5/3/2024
59,spiral matrix II,没什么技巧，就是硬写，但是一定要注意开闭区间,5/4/2024
203,remove linked list elements,简单，注意用dummy head,5/4/2024
707,design linked list,一定要注意长度判断条件，细节很多,5/4/2024
206,reverse linked list,两个细节点，一定要画图考虑清楚，很容易死循环,5/4/2024
24,swap nodes in pairs,也是要注意细节，画图说明,5/4/2024
19,remove nth node from end of list,也是双指针法,5/5/2024
2.07,intersection of two linked lists LCCI,双指针。写得有一点冗余，其实cnt可以从0开始计数就会少一些事,5/5/2024
142,linked list cycle II,最讨巧的就是set()方法。另一个是快满指针法，要数学证明,5/5/2024
242,valid anagram,用defaultdict或者counter写的飞快,5/5/2024
349,intersection of two arrays,同上，defaultdict或者counter。最后一步要转化为list,5/5/2024
202,happy number,这题不会，抄的。其实不是数学题，sum会重复的,5/5/2024
1,two sum,这题注意审题，只要2个数。而且解答巧在用一个循环就判断完了,5/5/2024
454,4sum II,不会，抄的。实际上4组数两两分组，就和1一样了,5/5/2024
383,ransom note,用counter无敌简单,5/6/2024
15,3sum,不会，抄的，谁能想到用双指针啊。另一个dict方法看不懂,5/6/2024
18,4sum,应该用双指针，但我用dict逻辑就比较清晰（就是慢了,5/6/2024
344,reverse string,easy,5/6/2024
541,reverse string II,简单，但我菜，看错题了。注意Python中的翻转用法,5/6/2024
,替换数字,没写。注意两个点：python的string不可更改，需要额外空间；isdigit()和''.join(),5/6/2024
151,reverse words in a string,python的split和join无敌简单,5/6/2024
28,find the index of the first occurrence in a string,这题用find或者index非常容易，但是要学会KMP,
459,repeated substring pattern,这题还真没思路，看了解答发现如此简单(移动匹配+find),
232,implement queue using stacks,有一些写法上的小细节要注意。In和out甚至不需要来回倒，一直放在out里都可以,
252,implement stack using queues,用一个deque就可以解决,
20,valid parentheses,有小细节,
1047,Remove All Adjacent Duplicates In String,easy,
150,Evaulate Reverse Polish Notation,easy,8/19/2024
239,Sliding Window Maximum,自己写的O(n*k)过不了，要用双端队列,8/19/2024
347,Top K Frequent Elements,没玩过的最大最小堆；最大堆是每次弹出最大元素；最小堆是弹出最小元素,8/19/2024
144,Binary Tree Preorder Traversal ,就是背！,8/21/2024
94,Binary Tree Inorder Traversal,same as above,8/21/2024
145,Binary Tree Postorder Traversal,order: the middle node!,8/21/2024
102,Binary Tree Level Order Traversal,queue,8/21/2024
107,Binary Tree Level Order Traversal II,最后反转即可,8/21/2024
199,Binary Tree Right Side View,只要判断是不是右侧（size-1）即可,8/21/2024
637,Average of Levels in Binary Tree,,8/21/2024
429,N-ary Tree Level Order Traversal,,8/21/2024
102,Binary Tree Level Order Traversal,,8/22/2024
515,Find Largest Value in Each Tree Row,,8/22/2024
116,Populating Next Right Pointers in Each Node,要用prev指针,8/24/2024
117,Populating Next Right Pointers in Each Node II,same as above,8/24/2024
104,Maximum Depth of Binary Tree,,8/24/2024
111,Minimum Depth of Binary Tree,只有左右孩子都不存在的时候才说明是遍历到最低点了,8/24/2024
226,Invert Binary Tree,反转左右孩子即可,8/24/2024
101,Symmetric Tree,递归outside和inside,8/25/2024
222,Count Complete Tree Nodes,,8/25/2024
110,Balanced Binary Tree,主要是层的数值关系要搞清楚,8/25/2024
257,Binary Tree Path,回溯,8/25/2024
404,Sume of Left Leaves,本质不难，但是一定要搞清楚左叶子的定义。在父节点就需要判定左叶子了,8/25/2024
513,Find Bottom Left Tree Value,层序,8/25/2024
112,Path Sum,就是257,8/26/2024
113,Path Sum II,,8/26/2024
106,Construct Binary Tree from Inorder and Postorder Traversal,中序+后序,8/26/2024
105,Construct Binary Tree from Preorder and Inorder Traversal,前序+中序,8/26/2024
654,Maximum Binary Tree,注意终止条件,8/26/2024
617,Merge Two Binary Trees,直接在root1上修改可以节省时间空间,8/26/2024
700,Search in a Binary Search Tree,搜索树！,8/26/2024
98,Vlidate Binary Searchc Tree,不能简单左<中，是左子树整个<中,8/27/2024
530,Minimum Absolute Difference in BST,和前面的一样,8/27/2024
501,Find Mode in Binary Search Tree,,8/27/2024
236,Lowest Common Ancestor of a Binary Tree,难的回溯,8/27/2024
235,Lowest Common Ancestor of a Binary Search Tree, ,8/27/2024
701,Insert into a Binary Search Tree,直接插到尾部,8/28/2024
450,Delete Node in a BST,背,8/28/2024
669,Trim a Binary Search Tree,,8/28/2024
108,Convert Sorted Array to Binary Search Tree,结合二分法,8/28/2024
538,Convert BST to Greater Tree,逆中序遍历,8/28/2024
77,Combinations,注意直接添加list到list中是引用！！如果是加实际数据，那要加上[:]。可以剪枝,8/29/2024
216,Combination Sum III,,8/30/2024
17,Letter Combinations of a Phone Number,,8/30/2024
39,Combination Sum,,8/30/2024
40,Combination Sum II,一直超时，两个if去重是关键,8/30/2024
131,Palindrome Partitioning,,8/30/2024
93,Restore IP Addresses,,8/30/2024
78,Subsets,收集所有的节点；终止条件！,8/30/2024
90,Subsets II,,8/30/2024
491,Non-decreasing Subsequences,需要用set()进行去重,9/1/2024
46,Permutations,"不需要startIdx,但是需要used",9/1/2024
332,Reconstruct Itinerary,很难,9/1/2024
51,N-Queens,也难啊,9/1/2024
37,Sodoku Solver,反而没之前的难,9/1/2024
455,Assign Cookies,,9/2/2024
376,Wiggle Subsequence,细节很多，讨论三种情况,9/2/2024
53,Maximum Subarray,简单，本应该自己想的,9/2/2024
122,Best Time to Buy and Sell Stock II,,9/2/2024
55,Jump Game,,9/2/2024
45,Jump Game II,移动下标达到了当前覆盖的最远距离下标时，步数就要加一,9/2/2024
1005,Maximize Sum Of Array After K Negations,不难但tricky,9/2/2024
134,Gas Station,没想到,9/3/2024
135,Candy,需要两遍遍历：左到右和右到左,9/3/2024
860,Lemonade Change,,9/3/2024
460,Queue Reconstruction by Height,妙啊，还涉及lambda和insert。如果是C++就需要上链表了std::list时,9/3/2024
452,Minimum Number of Arrows to Burst Ballons,更新右侧边界,9/3/2024
435,Non-overlapping Intervals,,9/4/2024
763,Partition Labels,先遍历一遍存储下标,9/4/2024
56,Merge Intervals,,9/4/2024
738,Monotone Increasing Digits,得从右往左遍历,9/4/2024
968,Binary Tree Cameras,怪难的,9/4/2024
509,Fibonacci Number,,9/5/2024
70,Climbing Stairs,看着难，实际上就是斐波那契，只是初始状态不同,9/5/2024
746,Min Cost Climbing Stairs,,9/5/2024
62,Unique Paths,,9/5/2024
63,Unique Paths II,,9/5/2024
343,Integer Break,拆分成dp[i-j] * j,9/5/2024
96,Unique Binary Search Trees,怪难理解的,9/6/2024
416,Partition Equal Subset Sum,最基础的背包,9/6/2024
1049,Last Stone Weight II,,9/6/2024
494,Target Sum,诀窍在于left-right=target和left+right=sum; 注意初始化条件,9/6/2024
474,Ones and Zeros,,9/6/2024
518,Coin Change II,,9/7/2024
377,Combination Sum IV,先物品后背包=组合，先背包后物品=排列,9/7/2024
322,Coin Change,需要初始化为最大值！,9/7/2024
279,Perfect Squares,,9/7/2024
139,Word Break,好新颖的题,9/7/2024
198,House Robber,0 1状态,9/8/2024
213,House Robber II,成环的考虑,9/8/2024
337,House Robber III,,9/8/2024
121,Best Time to Buy and Sell Stock,,9/8/2024
122,Best Time to Buy and Sell Stock II,,9/8/2024
