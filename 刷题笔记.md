## 数组

### 二分法

704. 二分查找：外面是一层while循环，左闭右开。注意`middle = left + (right - left) / 2`这种写法（如果直接相加小心超过int上限

### 双指针法

27. 移除元素：一开始是重合的，如果fast指针遇到了要移除的元素就先走
28. 有序数组的平方：从两头往里比较，`A[i] * A[i] < A[j] * A[j]` 那么`result[k--] = A[j] * A[j];`

29. 三数之和：先固定第一个数，第二个数left为`i+1`，第三个数right从末尾往左

30. 四数之和：先把前两个数加上，然后继续left & right往中间移动，和三数之和一样

344. 反转字符串

541. 反转字符串II

### 滑动窗口

209. 长度最小的子数组

### 前缀和

区间和：可以用一个额外数组`p[i]`表示`vec[i]`从下标为0一直加到i的和。这样求区间和可以直接做减法。

### 其他

59. 螺旋矩阵II：没技巧，纯靠算。`loop, mid = n // 2, n // 2`，`loop`在最外层控制循环次数。

44. 开发商购买土地：行末尾统计的是列划分，列末尾统计的是行划分

## 链表

```c++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
// 通过自己定义的构造函数初始化
ListNode* head = new ListNode(5);
// 使用默认构造函数初始化
ListNode* head = new ListNode();
head->val = 5;
```

### 虚拟头节点

203. 移除链表元素：不是很需要双指针，判断`while(curr.next)`就行

707. 设计链表

206. 反转链表

24. 两两交换链表中的节点

19. 删除链表的倒数第N个节点：fast先走n+1，然后判断是否为null更方便

02.07. 链表相交

### 其他

142. 环形链表II：`x = (n - 1) (y + z) + z`。当 n为1的时候， `x = z`。即，快慢指针相遇后，让一个指针从头节点出发，让它和快慢指针同时走，再相遇就是环的入口结点。

## 哈希表

242. 有效的字母异位词

349. 两个数组的交集

202. 快乐数：会重复

1. 两数之和：遍历过的就加入集合，然后在里面找`complement = target - num`即可。

454. 四数相加II

383. 赎金信

## 字符串

> 注意三个函数:
>
> 而且注意，python里的string是不可变的。如果要变，就要创建一个新的对象。
>
> `join()`：用指定字符链接
>
> `split()`：用指定字符分割（默认为所有）
>
> `strip()`：只去除前后
>
> `reversed()`用于字符串，但是会返回迭代器，需要用`join`连接
>
> `reverse()`用于list

344. 反转字符串

541. 反转字符串II

151. 翻转字符串里的单词

### KMP

```python
    def getNext(self, next: List[int], s: str) -> None:
        j = 0
        next[0] = 0
        for i in range(1, len(s)):
            while j > 0 and s[i] != s[j]:
                j = next[j - 1]
            if s[i] == s[j]:
                j += 1
            next[i] = j
```

28. 实现 strStr()：我觉得难。实在不行就用find吧。

459. 重复的子字符串：判断条件是`if nxt[-1] != 0 and len(s) % (len(s) - nxt[-1]) == 0:`

## 栈与队列

232. 用栈实现队列
233. 用队列实现栈：可以优化只使用一个队列

20. 有效的括号

1047. 删除字符串中的所有相邻重复项

150. 逆波兰表达式求值

239. 滑动窗口最大值：单调队列

347. 前K个高频元素：优先级队列，`heapq.heappush(pri_que, (freq, key))`。第一个元素freq为排序的索引

## 二叉树

> 完全二叉树：如果有值，必然在左侧
>
> 二叉搜索树：左<中<右
>
> 平衡二叉搜索树AVL

递归遍历/迭代遍历(栈，中结点后push(NULL))：

144. 二叉树的前序遍历
145. 二叉树的中序遍历
146. 二叉树的后序遍历

层序遍历（队列）：

102. 二叉树的层序遍历

107. 二叉树的层次遍历 II

199. 二叉树的右视图

637. 二叉树的层平均值

429. N叉树的层序遍历

515. 在每个树行中找最大值

116. 填充每个节点的下一个右侧节点指针

117. 填充每个节点的下一个右侧节点指针II

104. 二叉树的最大深度

111. 二叉树的最小深度



101. 对称二叉树：使用递归

222. 完全二叉树的节点个数

110. 平衡二叉树

257. 二叉树的所有路径：需要回溯

404. 左叶子之和

513. 找树左下角的值：层序

112. 路径总和
113. 路径总和 II

105. **从前序与中序遍历序列构造二叉树**

106. **从中序与后序遍历序列构造二叉树**

654. 最大二叉树

617. 合并二叉树

700. 二叉搜索树中的搜索

98. 验证二叉搜索树：中序遍历后加入数组，然后判定是否是升序数组
