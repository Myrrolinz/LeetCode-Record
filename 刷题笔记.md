## 数组

### 二分法

704. 二分查找：外面是一层while循环，左闭右开。注意`middle = left + (right - left) / 2`这种写法（如果直接相加小心超过int上限

### 双指针法

27. 移除元素：一开始是重合的，如果fast指针遇到了要移除的元素就先走
28. 有序数组的平方：从两头往里比较，`A[i] * A[i] < A[j] * A[j]` 那么`result[k--] = A[j] * A[j];`

29. 三数之和：先固定第一个数，第二个数left为`i+1`，第三个数right从末尾往左

30. 四数之和：先把前两个数加上，然后继续left & right往中间移动，和三数之和一样

344. 反转字符串

541. 反转字符串II

### 滑动窗口

209. 长度最小的子数组

### 前缀和

区间和：可以用一个额外数组`p[i]`表示`vec[i]`从下标为0一直加到i的和。这样求区间和可以直接做减法。

### 其他

59. 螺旋矩阵II：没技巧，纯靠算。`loop, mid = n // 2, n // 2`，`loop`在最外层控制循环次数。

44. 开发商购买土地：行末尾统计的是列划分，列末尾统计的是行划分

## 链表

```c++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
// 通过自己定义的构造函数初始化
ListNode* head = new ListNode(5);
// 使用默认构造函数初始化
ListNode* head = new ListNode();
head->val = 5;
```

### 虚拟头节点

203. 移除链表元素：不是很需要双指针，判断`while(curr.next)`就行

707. 设计链表

206. 反转链表

24. 两两交换链表中的节点

19. 删除链表的倒数第N个节点：fast先走n+1，然后判断是否为null更方便

02.07. 链表相交

### 其他

142. 环形链表II：`x = (n - 1) (y + z) + z`。当 n为1的时候， `x = z`。即，快慢指针相遇后，让一个指针从头节点出发，让它和快慢指针同时走，再相遇就是环的入口结点。

## 哈希表

242. 有效的字母异位词

349. 两个数组的交集

202. 快乐数：会重复

1. 两数之和：遍历过的就加入集合，然后在里面找`complement = target - num`即可。

454. 四数相加II

383. 赎金信

## 字符串

> 注意三个函数:
>
> 而且注意，python里的string是不可变的。如果要变，就要创建一个新的对象。
>
> `join()`：用指定字符链接
>
> `split()`：用指定字符分割（默认为所有）
>
> `strip()`：只去除前后
>
> `reversed()`用于字符串，但是会返回迭代器，需要用`join`连接
>
> `reverse()`用于list

344. 反转字符串

541. 反转字符串II

151. 翻转字符串里的单词

### KMP

```python
    def getNext(self, next: List[int], s: str) -> None:
        j = 0
        next[0] = 0
        for i in range(1, len(s)):
            while j > 0 and s[i] != s[j]:
                j = next[j - 1]
            if s[i] == s[j]:
                j += 1
            next[i] = j
```

28. 实现 strStr()：我觉得难。实在不行就用find吧。

459. 重复的子字符串：判断条件是`if nxt[-1] != 0 and len(s) % (len(s) - nxt[-1]) == 0:`

## 栈与队列

232. 用栈实现队列

225. 用队列实现栈：可以优化只使用一个队列
