## 数组

### 二分法

704. 二分查找：外面是一层while循环，左闭右开。注意`middle = left + (right - left) / 2`这种写法（如果直接相加小心超过int上限

### 双指针法

27. 移除元素：一开始是重合的，如果fast指针遇到了要移除的元素就先走
28. 有序数组的平方：从两头往里比较，`A[i] * A[i] < A[j] * A[j]` 那么`result[k--] = A[j] * A[j];`

29. 三数之和：先固定第一个数，第二个数left为`i+1`，第三个数right从末尾往左

30. 四数之和：先把前两个数加上，然后继续left & right往中间移动，和三数之和一样

344. 反转字符串

541. 反转字符串II

### 滑动窗口

209. 长度最小的子数组

### 前缀和

区间和：可以用一个额外数组`p[i]`表示`vec[i]`从下标为0一直加到i的和。这样求区间和可以直接做减法。

### 其他

59. 螺旋矩阵II：没技巧，纯靠算。`loop, mid = n // 2, n // 2`，`loop`在最外层控制循环次数。

44. 开发商购买土地：行末尾统计的是列划分，列末尾统计的是行划分

## 链表

```c++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
// 通过自己定义的构造函数初始化
ListNode* head = new ListNode(5);
// 使用默认构造函数初始化
ListNode* head = new ListNode();
head->val = 5;
```

### 虚拟头节点

203. 移除链表元素：不是很需要双指针，判断`while(curr.next)`就行

707. 设计链表

206. 反转链表

24. 两两交换链表中的节点

19. 删除链表的倒数第N个节点：fast先走n+1，然后判断是否为null更方便

02.07. 链表相交

### 其他

142. 环形链表II：`x = (n - 1) (y + z) + z`。当 n为1的时候， `x = z`。即，快慢指针相遇后，让一个指针从头节点出发，让它和快慢指针同时走，再相遇就是环的入口结点。

## 哈希表

242. 有效的字母异位词

349. 两个数组的交集

202. 快乐数：会重复

1. 两数之和：遍历过的就加入集合，然后在里面找`complement = target - num`即可。

454. 四数相加II

383. 赎金信

## 字符串

> 注意三个函数:
>
> 而且注意，python里的string是不可变的。如果要变，就要创建一个新的对象。
>
> `join()`：用指定字符链接
>
> `split()`：用指定字符分割（默认为所有）
>
> `strip()`：只去除前后
>
> `reversed()`用于字符串，但是会返回迭代器，需要用`join`连接
>
> `reverse()`用于list

344. 反转字符串

541. 反转字符串II

151. 翻转字符串里的单词

### KMP

```python
    def getNext(self, next: List[int], s: str) -> None:
        j = 0
        next[0] = 0
        for i in range(1, len(s)):
            while j > 0 and s[i] != s[j]:
                j = next[j - 1]
            if s[i] == s[j]:
                j += 1
            next[i] = j
```

28. 实现 strStr()：我觉得难。实在不行就用find吧。

459. 重复的子字符串：判断条件是`if nxt[-1] != 0 and len(s) % (len(s) - nxt[-1]) == 0:`

## 栈与队列

232. 用栈实现队列
233. 用队列实现栈：可以优化只使用一个队列

20. 有效的括号

1047. 删除字符串中的所有相邻重复项

150. 逆波兰表达式求值

239. 滑动窗口最大值：单调队列

347. 前K个高频元素：优先级队列，`heapq.heappush(pri_que, (freq, key))`。第一个元素freq为排序的索引

## 二叉树

> 完全二叉树：如果有值，必然在左侧
>
> 二叉搜索树：左<中<右
>
> 平衡二叉搜索树AVL

递归遍历/迭代遍历(栈，中结点后push(NULL))：

144. 二叉树的前序遍历
145. 二叉树的中序遍历
146. 二叉树的后序遍历

层序遍历（队列）：

102. 二叉树的层序遍历

107. 二叉树的层次遍历 II

199. 二叉树的右视图

637. 二叉树的层平均值

429. N叉树的层序遍历

515. 在每个树行中找最大值

116. 填充每个节点的下一个右侧节点指针

117. 填充每个节点的下一个右侧节点指针II

104. 二叉树的最大深度

111. 二叉树的最小深度



101. 对称二叉树：使用递归
102. 完全二叉树的节点个数
103. 平衡二叉树
104. 二叉树的所有路径：需要回溯
105. 左叶子之和
106. 找树左下角的值：层序
107. 路径总和
108. 路径总和 II
109. **从前序与中序遍历序列构造二叉树**
110. **从中序与后序遍历序列构造二叉树**
111. 最大二叉树
112. 合并二叉树
113. 二叉搜索树中的搜索
114. 验证二叉搜索树：中序遍历后加入数组，然后判定是否是升序数组

530. 二叉搜索树的最小绝对差：中序

501. 二叉搜索树中的众数

236. 二叉树的最近公共祖先

235. 二叉搜索树的最近公共祖先：利用其性质，如果`p < root.val < q`，可以直接返回`root`了

701. 二叉搜索树中的插入操作

450. 删除二叉搜索树中的节点：最关键的操作，把值为key的结点和右孩子的最左侧孩子互换

669. 修剪二叉搜索树：有点tricky

108. 将有序数组转换为二叉搜索树：找到中点，再分别递归左右

538. 把二叉搜索树转换为累加树：中序遍历，但从右边开始版

## 回溯

```C++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果 // 可能不止一个pop，还有其他需要撤销的
    }
}
```

剪枝优化：**如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了**。

**无放回组合**：**一个**集合，需要`startIndex`

77. 无列：问题

78. 组合总和III

131. 分割回文串

93. 复原IP地址

**无放回有重复**：

78. 组合总和II：有重复元素，sort后去重（和前一个一样直接跳过）

79. 子集II：如前，直接跳过。也可以用`used`去重。

80. 递增子序列：不可排序，需要使用`set()`对本层使用过的节点去重（横向去重）



**多个**集合互不影响，不需要`startIndex`

77. 电话号码的字母组合



**有放回组合**：

39. 组合总和：`self.backtracking(candidates, target, total, i, path, result)  # 不用i+1了，表示可以重复读取当前的数`



**排列**：不用`startIndex`，但要用`used`数组去重

46. 全排列：不重复

47. 全排列 II：重复。`if (i > 0 and nums[i] == nums[i - 1] and not used[i - 1]) or used[i]: continue`



推荐用used，复杂度更低。

332. 重新安排行程

51. N皇后：`chessboard = ['.' * n for _ in range(n)]`这样用棋盘。递归row，while col，在while里检查is_valid，确认后再递归。

37. 解数独：行列和数全用for来循环了，然后就一个`self.backtracking(board)`。就是return 为bool。



## 贪心

455. 分发饼干：小饼干优先

376. 摆动序列：**删除单调坡度上的节点，那么这个坡度就可以有两个局部峰值**。考虑平坡情况：上下坡，首位两端，单调坡。
     `if (preDiff <= 0 and curDiff > 0) or (preDiff >= 0 and curDiff < 0):`

     也可以用dp做，但是复杂度更高

53. 最大子序和

122. 买卖股票的最佳时机 II：多次买卖

55. 跳跃游戏
